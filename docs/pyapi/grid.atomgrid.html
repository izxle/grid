

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>grid.atomgrid module &mdash; grid  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/override.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/override.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="grid.basegrid module" href="grid.basegrid.html" />
    <link rel="prev" title="grid.angular module" href="grid.angular.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> grid
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#downloading-code">Downloading Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#id1">Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../onedgrids.html">One-Dimensional Grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="../radial_transf.html">Radial Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conventions.html">Conventions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#spherical-coordinates">Spherical Coordinates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#spherical-harmonics">Spherical Harmonics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../conventions.html#ordering">Ordering</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../conventions.html#angular-grids">Angular Grids</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Example Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/Molecular_Grid.html">Molecular Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Integration">Integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Example:-Electron-Density">Example: Electron Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Interpolation">Interpolation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid.html#id1">Example: Electron Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Derivative-Interpolation">Derivative Interpolation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Example:-Weizsacker-Kinetic-Energy-Density">Example: Weizsacker Kinetic Energy Density</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Solving-Poisson-Equation">Solving Poisson Equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid.html#Example:-Electrostatic-Potential">Example: Electrostatic Potential</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html">Constructing Molecular Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#Molecular-Grid-Details">Molecular Grid Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#Construction-of-Molecular-Grid">Construction of Molecular Grid</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#Constructor">Constructor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#from_preset-method">from_preset method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#from_size-method">from_size method</a></li>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Molecular_Grid_Construction.html#from_pruned-method">from_pruned method</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/Cubic_Grids.html">Cubic Grids</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Cubic_Grids.html#Tensor-1D-Grids">Tensor 1D Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../notebooks/Cubic_Grids.html#Interpolation">Interpolation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Cubic_Grids.html#Uniform-Grid">Uniform Grid</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/Interpolation_and_Poisson.html">Interpolation and Solving Poisson’s Equation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Interpolation_and_Poisson.html#Details">Details</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Interpolation_and_Poisson.html#Example:-Unit-charge-distribution">Example: Unit-charge distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../notebooks/Interpolation_and_Poisson.html#Solving-Poisson-Equation">Solving Poisson Equation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/Multipole_Moments.html">Multipole Moments (In Progress)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">grid</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="grid.html">grid package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="grid.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="grid.angular.html">grid.angular module</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">grid.atomgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.basegrid.html">grid.basegrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.becke.html">grid.becke module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.cubic.html">grid.cubic module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.hirshfeld.html">grid.hirshfeld module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.molgrid.html">grid.molgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.ode.html">grid.ode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.onedgrid.html">grid.onedgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.periodicgrid.html">grid.periodicgrid module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.poisson.html">grid.poisson module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.rtransform.html">grid.rtransform module</a></li>
<li class="toctree-l4"><a class="reference internal" href="grid.utils.html">grid.utils module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="grid.html#module-grid">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">grid</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">grid</a> &raquo;</li>
        
          <li><a href="grid.html">grid package</a> &raquo;</li>
        
      <li>grid.atomgrid module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/pyapi/grid.atomgrid.rst" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-grid.atomgrid">
<span id="grid-atomgrid-module"></span><h1>grid.atomgrid module<a class="headerlink" href="#module-grid.atomgrid" title="Permalink to this heading">¶</a></h1>
<p>Module for generating AtomGrid.</p>
<dl class="py class">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AtomGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgrid</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spherical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="grid.basegrid.html#grid.basegrid.Grid" title="grid.basegrid.Grid"><code class="xref py py-class docutils literal notranslate"><span class="pre">Grid</span></code></a></p>
<p>Atomic grid construction class for integrating three-dimensional functions.</p>
<p>Atomic grid is composed of a radial grid <span class="math notranslate nohighlight">\(\{(r_i, w_i)\}_{i=1}^{N}\)</span> meant to
integrate the radius coordinate in spherical coordinates. Further, each radial point
is associated with an Angular (Lebedev or Symmetric spherical t-design) grid
<span class="math notranslate nohighlight">\(\{(\theta^i_j, \phi^i_j, w_j^i)\}_{j=1}^{M_i}\)</span> that integrates over a sphere
(angles in spherical coordinates).  The atomic grid points can also be centered at a given
location.</p>
<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgrid</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degrees</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spherical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct atomic grid for given arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rgrid</strong> (<a class="reference internal" href="grid.basegrid.html#grid.basegrid.OneDGrid" title="grid.basegrid.OneDGrid"><em>OneDGrid</em></a>) – The (one-dimensional) radial grid representing the radius of spherical grids.</p></li>
<li><p><strong>degrees</strong> (<em>ndarray</em><em>(</em><em>N</em><em>, </em><em>dtype=int</em><em>) or </em><em>list</em><em>, </em><em>keyword-only argument</em>) – Sequence of angular grid degrees used for constructing spherical grids at each
radial grid point.
If only one degree is given, the specified degree is used for all spherical grids.
If the given degree is not supported, the next largest degree is used.</p></li>
<li><p><strong>sizes</strong> (<em>ndarray</em><em>(</em><em>N</em><em>, </em><em>dtype=int</em><em>) or </em><em>list</em><em>, </em><em>keyword-only argument</em>) – Sequence of angular grid sizes used for constructing spherical grids at each
radial grid point.
If only one size is given, the specified size is used for all spherical grids.
If the given size is not supported, the next largest size is used.
If both degrees and sizes are given, degrees is used for making the spherical grids.</p></li>
<li><p><strong>center</strong> (<em>ndarray</em><em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>keyword-only argument</em>) – Cartesian coordinates of the grid center. If <cite>None</cite>, the origin is used.</p></li>
<li><p><strong>rotate</strong> (<em>int</em><em>, </em><em>optional</em>) – Integer used as a seed for generating random rotation matrices to rotate the angular
spherical grids at each radial grid point. If the integer is zero, then no rotate
is used.</p></li>
<li><p><strong>use_spherical</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, loads the symmetric spherical t-design grid rather than the Lebedev-Laikov
grid for the angular grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.basis">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">basis</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate spherical harmonic basis evaluated on atomic grid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.center">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinates of the grid center.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(3,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.convert_cartesian_to_spherical">
<span class="sig-name descname"><span class="pre">convert_cartesian_to_spherical</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.convert_cartesian_to_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a set of points from Cartesian to spherical coordinates.</p>
<p>The conversion is defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    r &amp;= \sqrt{x^2 + y^2 + z^2}\\
    \theta &amp;= arc\tan (\frac{y}{x})\\
    \phi &amp;= arc\cos(\frac{z}{r})
\end{align}\end{split}\]</div>
<p>with the canonical choice <span class="math notranslate nohighlight">\(r=0\)</span>, then <span class="math notranslate nohighlight">\(\theta,\phi = 0\)</span>.
If the <cite>points</cite> attribute is not specified, then atomic grid points are used
and the canonical choice when <span class="math notranslate nohighlight">\(r=0\)</span>, is the points
<span class="math notranslate nohighlight">\((r=0, \theta_j, \phi_j)\)</span> where <span class="math notranslate nohighlight">\((\theta_j, \phi_j)\)</span> come
from the Angular grid with the degree at <span class="math notranslate nohighlight">\(r=0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>ndarray</em><em>(</em><em>n</em><em>, </em><em>3</em><em>)</em><em>, </em><em>optional</em>) – Points in three-dimensions. Atomic grid points will be used if <cite>points</cite> is not given</p></li>
<li><p><strong>center</strong> (<em>ndarray</em><em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Center of the atomic grid points.  If <cite>center</cite> is not provided, then the atomic
center of this class is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Spherical coordinates of atoms respect to the center
(radius <span class="math notranslate nohighlight">\(r\)</span>, azimuthal <span class="math notranslate nohighlight">\(\theta\)</span>, polar <span class="math notranslate nohighlight">\(\phi\)</span>).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(N, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.degrees">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">degrees</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of each angular grid at each radial point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.from_preset">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_preset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgrid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atnum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spherical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.from_preset" title="Permalink to this definition">¶</a></dt>
<dd><p>High level api to construct an atomic grid with preset arguments.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># construct an atomic grid for H with fine grid setting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atgrid</span> <span class="o">=</span> <span class="n">AtomGrid</span><span class="o">.</span><span class="n">from_preset</span><span class="p">(</span><span class="n">rgrid</span><span class="p">,</span> <span class="n">atnum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="s2">&quot;fine&quot;</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rgrid</strong> (<a class="reference internal" href="grid.basegrid.html#grid.basegrid.OneDGrid" title="grid.basegrid.OneDGrid"><em>OneDGrid</em></a><em>, </em><em>optional</em>) – The (1-dimensional) radial grid representing the radius of spherical grids.</p></li>
<li><p><strong>atnum</strong> (<em>int</em><em>, </em><em>keyword-only argument</em>) – The atomic number specifying the predefined grid.</p></li>
<li><p><strong>preset</strong> (<em>str</em><em>, </em><em>keyword-only argument</em>) – The name of predefined grid specifying the radial sectors and their corresponding
number of angular grid points. Supported preset options include:
‘coarse’, ‘medium’, ‘fine’, ‘veryfine’, ‘ultrafine’, and ‘insane’.</p></li>
<li><p><strong>center</strong> (<em>ndarray</em><em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>keyword-only argument</em>) – Cartesian coordinates of the grid center. If <cite>None</cite>, the origin is used.</p></li>
<li><p><strong>rotate</strong> (<em>int</em><em>, </em><em>optional</em>) – Integer used as a seed for generating random rotation matrices to rotate the angular
spherical grids at each radial grid point. If the integer is zero, then no rotate
is used.</p></li>
<li><p><strong>use_spherical</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, loads the symmetric spherical t-design grid rather than the Lebedev-Laikov
grid for the angular grid.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.from_pruned">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_pruned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sectors_r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sectors_degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sectors_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_spherical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.from_pruned" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize AtomGrid class that splits radial sections into sectors which specified degrees.</p>
<p>Given a sequence of radial sectors <span class="math notranslate nohighlight">\(\{a_i\}_{i=1}^Q\)</span>, a radius number <span class="math notranslate nohighlight">\(R\)</span>
and angular degree sectors <span class="math notranslate nohighlight">\(\{L_i \}_{i=1}^{Q+1}\)</span>.  This assigned the degrees
to the following radial points:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align*}
    &amp;L_1 \text{ when } r &lt; R a_1 \\
    &amp;L_2 \text{ when } R a_1 \leq r &lt; R a_2
    \vdots \\
    &amp;L_{Q+1} \text{ when } R a_{Q} &lt; r.
\end{align*}\end{split}\]</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sectors_r</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sectors_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="go"># 0 &lt;= r &lt; 0.5 radius, angular grid with degree 3</span>
<span class="go"># 0.5 radius &lt;= r &lt; radius, angular grid with degree 7</span>
<span class="go"># rad &lt;= r &lt; 1.5 radius, angular grid with degree 5</span>
<span class="go"># 1.5 radius &lt;= r, angular grid with degree 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atgrid</span> <span class="o">=</span> <span class="n">AtomGrid</span><span class="o">.</span><span class="n">from_pruned</span><span class="p">(</span><span class="n">rgrid</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">sectors_r</span><span class="p">,</span> <span class="n">sectors_degree</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rgrid</strong> (<a class="reference internal" href="grid.basegrid.html#grid.basegrid.OneDGrid" title="grid.basegrid.OneDGrid"><em>OneDGrid</em></a>) – The (one-dimensional) radial grid representing the radius of spherical grids.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – The atomic radius to be multiplied with <cite>r_sectors</cite> (to make them atom specific).</p></li>
<li><p><strong>sectors_r</strong> (<em>ndarray</em><em>(</em><em>N</em><em>,</em><em>)</em><em>, </em><em>keyword-only argument</em>) – Sequence of boundary points specifying radial sectors of the pruned grid.
The first sector is <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">radius*sectors_r[0]]</span></code>, then <code class="docutils literal notranslate"><span class="pre">[radius*sectors_r[0],</span>
<span class="pre">radius*sectors_r[1]]</span></code>, and so on.</p></li>
<li><p><strong>sectors_degree</strong> (<em>ndarray</em><em>(</em><em>N + 1</em><em>, </em><em>dtype=int</em><em>)</em><em>, </em><em>keyword-only argument</em>) – Sequence of angular degrees for each radial sector of the pruned grid.</p></li>
<li><p><strong>sectors_size</strong> (<em>ndarray</em><em>(</em><em>N + 1</em><em>, </em><em>dtype=int</em><em>)</em><em>, </em><em>keyword-only argument</em>) – Sequence of angular sizes for each radial sector of the pruned grid.
If both sectors_degree and sectors_size are given, sectors_degree is used.</p></li>
<li><p><strong>center</strong> (<em>ndarray</em><em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em><em>, </em><em>keyword-only argument</em>) – Cartesian coordinates of the grid center. If <cite>None</cite>, the origin is used.</p></li>
<li><p><strong>rotate</strong> (<em>int</em><em>, </em><em>optional</em>) – Integer used as a seed for generating random rotation matrices to rotate the angular
spherical grids at each radial grid point. If the integer is zero, then no rotate
is used.</p></li>
<li><p><strong>use_spherical</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, loads the symmetric spherical t-design grid rather than the Lebedev-Laikov
grid for the angular grid.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Generated AtomGrid instance for this special init method.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#grid.atomgrid.AtomGrid" title="grid.atomgrid.AtomGrid">AtomGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.get_localgrid">
<span class="sig-name descname"><span class="pre">get_localgrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.get_localgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a grid contain points within the given radius of center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> (<em>float</em><em> or </em><em>np.array</em><em>(</em><em>M</em><em>,</em><em>)</em>) – Cartesian coordinates of the center of the local grid.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Radius of sphere around the center. When equal to np.inf, the
local grid coincides with the whole grid, which can be useful for
debugging.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Instance of LocalGrid.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="grid.basegrid.html#grid.basegrid.LocalGrid" title="grid.basegrid.LocalGrid">LocalGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.get_shell_grid">
<span class="sig-name descname"><span class="pre">get_shell_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_sq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.get_shell_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the spherical integral grid at radial point from specified index.</p>
<p>The spherical integration grid has points scaled with the ith radial point
and weights multipled by the ith weight of the radial grid.</p>
<p>Note that when <span class="math notranslate nohighlight">\(r=0\)</span> then the Cartesian points are all zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – Index of radial points.</p></li>
<li><p><strong>r_sq</strong> (<em>bool</em><em>, </em><em>default True</em>) – If true, multiplies the angular grid weights with r**2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>AngularGrid at given radial index position and weights.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="grid.angular.html#grid.angular.AngularGrid" title="grid.angular.AngularGrid">AngularGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.indices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">indices</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Indices saved for each spherical shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(M+1,)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">value_arrays</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate over the whole grid for given multiple value arrays.</p>
<p>Product of all value_arrays will be computed element-wise then integrated on the grid
with its weights:</p>
<div class="math notranslate nohighlight">
\[\int w(x) \prod_i f_i(x) dx.\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>*value_arrays</strong> (<em>np.ndarray</em><em>(</em><em>N</em><em>, </em><em>)</em>) – One or multiple value array to integrate.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The calculated integral over given integrand or function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.integrate_angular_coordinates">
<span class="sig-name descname"><span class="pre">integrate_angular_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.integrate_angular_coordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate the angular coordinates of a sequence of functions.</p>
<p>Given a series of functions <span class="math notranslate nohighlight">\(f_k \in L^2(\mathbb{R}^3)\)</span>, this returns the values</p>
<div class="math notranslate nohighlight">
\[f_k(r_i) = \int \int f(r_i, \theta, \phi) sin(\theta) d\theta d\phi\]</div>
<p>on each radial point <span class="math notranslate nohighlight">\(r_i\)</span> in the atomic grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func_vals</strong> (<em>ndarray</em><em>(</em><em>...</em><em>, </em><em>N</em><em>)</em>) – The function values evaluated on all <span class="math notranslate nohighlight">\(N\)</span> points on the atomic grid
for many types of functions.  This can also be one-dimensional.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The function <span class="math notranslate nohighlight">\(f_{...}(r_i)\)</span> on each <span class="math notranslate nohighlight">\(M\)</span> radial points.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(…, M)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.interpolate">
<span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return function that interpolates (and its derivatives) from function values.</p>
<p>Any real-valued function <span class="math notranslate nohighlight">\(f(r, \theta, \phi)\)</span> can be decomposed as</p>
<div class="math notranslate nohighlight">
\[f(r, \theta, \phi) = \sum_l \sum_{m=-l}^l \sum_i \rho_{ilm}(r) Y_{lm}(\theta, \phi)\]</div>
<p>A cubic spline is used to interpolate the radial functions <span class="math notranslate nohighlight">\(\sum_i \rho_{ilm}(r)\)</span>.
This is then multipled by the corresponding spherical harmonics at all
<span class="math notranslate nohighlight">\((\theta_j, \phi_j)\)</span> angles and summed to obtain the equation above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func_vals</strong> (<em>ndarray</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The function values evaluated on all <span class="math notranslate nohighlight">\(N\)</span> points on the atomic grid.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>Callable function that interpolates the function and its derivative provided.
The function takes the following attributes:</p>
<blockquote>
<div><dl class="simple">
<dt>points<span class="classifier">ndarray(N, 3)</span></dt><dd><p>Cartesian coordinates of <span class="math notranslate nohighlight">\(N\)</span> points to evaluate the splines on.</p>
</dd>
<dt>deriv<span class="classifier">int, optional</span></dt><dd><p>If deriv is zero, then only returns function values. If it is one, then
returns the first derivative of the interpolated function with respect to either
Cartesian or spherical coordinates. Only higher-order derivatives
(<a href="#id1"><span class="problematic" id="id2">`</span></a>deriv`=2,3) are supported for the derivatives wrt to radial components.</p>
</dd>
<dt>deriv_spherical<span class="classifier">bool</span></dt><dd><p>If True, then returns the derivatives with respect to spherical coordinates
<span class="math notranslate nohighlight">\((r, \theta, \phi)\)</span>. Default False.</p>
</dd>
<dt>only_radial_deriv<span class="classifier">bool</span></dt><dd><p>If true, then the derivative wrt to radius <span class="math notranslate nohighlight">\(r\)</span> is returned.</p>
</dd>
</dl>
</div></blockquote>
<p>This function returns the following.</p>
<blockquote>
<div><dl class="simple">
<dt>ndarray(M,…):</dt><dd><p>The interpolated function values or its derivatives with respect to Cartesian
<span class="math notranslate nohighlight">\((x,y,z)\)</span> or if <cite>deriv_spherical</cite> then <span class="math notranslate nohighlight">\((r, \theta, \phi)\)</span> or
if <cite>only_radial_derivs</cite> then derivative wrt to <span class="math notranslate nohighlight">\(r\)</span> is only returned.</p>
</dd>
</dl>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Callable[[ndarray(M, 3), int] -&gt; ndarray(M)]</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># First generate a atomic grid with raidal points that have all degree 10.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">grid.basegrid</span> <span class="kn">import</span> <span class="n">OneDGrid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radial_grid</span> <span class="o">=</span> <span class="n">OneDGrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atom_grid</span> <span class="o">=</span> <span class="n">AtomGrid</span><span class="p">(</span><span class="n">radial_grid</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="go"># Consider the function (3x^2 + 4y^2 + 5z^2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">polynomial_func</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span> <span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">*</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mf">5.0</span> <span class="o">*</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mf">2.0</span>
<span class="go"># Evaluate function values and interpolate them</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_vals</span> <span class="o">=</span> <span class="n">polynomial_func</span><span class="p">(</span><span class="n">atom_grid</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolate_func</span> <span class="o">=</span> <span class="n">atom_grid</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">func_vals</span><span class="p">)</span>
<span class="go"># To interpolate at new points.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolate_vals</span> <span class="o">=</span> <span class="n">interpolate_func</span><span class="p">(</span><span class="n">new_pts</span><span class="p">)</span>
<span class="go"># Can calculate first derivative wrt to Cartesian or spherical</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolate_derivs</span> <span class="o">=</span> <span class="n">interpolate_func</span><span class="p">(</span><span class="n">new_pts</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolate_derivs_sph</span> <span class="o">=</span> <span class="n">interpolate_func</span><span class="p">(</span><span class="n">new_pts</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">deriv_spherical</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go"># Only higher-order derivatives are supported for the radius coordinate r.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interpolated_derivs_radial</span> <span class="o">=</span> <span class="n">interpolate_func</span><span class="p">(</span><span class="n">new_pts</span><span class="p">,</span> <span class="n">deriv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">only_radial_derivs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.l_max">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">l_max</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.l_max" title="Permalink to this definition">¶</a></dt>
<dd><p>Largest angular degree L value in angular grids.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.moments">
<span class="sig-name descname"><span class="pre">moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orders</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_mom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cartesian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_orders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the multipole moment integral of a function over centers.</p>
<p>The Cartesian type moments are:</p>
<div class="math notranslate nohighlight">
\[m_{n_x, n_y, n_z} = \int (x - X_c)^{n_x} (y - Y_c)^{n_y} (z - Z_c)^{n_z} f(r) dr,\]</div>
<p>where <span class="math notranslate nohighlight">\(\textbf{R}_c = (X_c, Y_c, Z_c)\)</span> is the center of the moment,
<span class="math notranslate nohighlight">\(\f(r)\)</span> is the density, and <span class="math notranslate nohighlight">\((n_x, n_y, n_z)\)</span> are the Cartesian orders.</p>
<p>The spherical/pure moments with <span class="math notranslate nohighlight">\((l, m)\)</span> parameter are:</p>
<div class="math notranslate nohighlight">
\[m_{lm} = \int | \textbf{r} - \textbf{R}_c|^l S_l^m(\theta, \phi) f(\textbf{r})
d\textbf{r},\]</div>
<p>where <span class="math notranslate nohighlight">\(S_l^m\)</span> is a regular, real solid harmonic.</p>
<p>The radial moments with <span class="math notranslate nohighlight">\(n\)</span> parameter are:</p>
<div class="math notranslate nohighlight">
\[m_n = \int | \textbf{r} - \textbf{R}_c|^{n} f(\textbf{r}) d\textbf{r}\]</div>
<p>The radial combined with spherical/pure moments <span class="math notranslate nohighlight">\((n, l, m)\)</span> are:</p>
<div class="math notranslate nohighlight">
\[m_{nlm} = \int | \textbf{r} - \textbf{R}_c|^{n+1} S_l^m(\theta, \phi) f(\textbf{r})
d\textbf{r}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orders</strong> (<em>int</em>) – Generates all orders with Horton order depending on the type of the multipole
moment <cite>type_mom</cite>.</p></li>
<li><p><strong>centers</strong> (<em>ndarray</em><em>(</em><em>M</em><em>,  </em><em>3</em><em>)</em>) – The centers <span class="math notranslate nohighlight">\(\textbf{R}_c\)</span> of the moments to compute from.</p></li>
<li><p><strong>func_vals</strong> (<em>ndarray</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The function <span class="math notranslate nohighlight">\(f\)</span> values evaluated on all <span class="math notranslate nohighlight">\(N\)</span> points on the integration
grid.</p></li>
<li><p><strong>type_mom</strong> (<em>str</em>) – The type of multipole moments: “cartesian”, “pure”, “radial” and “pure-radial”.</p></li>
<li><p><strong>return_orders</strong> (<em>bool</em>) – If true, it will also return a list of size <span class="math notranslate nohighlight">\(L\)</span> of the orders
corresponding to each integral/row of the output.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Computes the moment integral of the function on the <cite>m`th center for all orders.
If `return_orders</cite> is true, then this also returns a list that describes what
each row/order is, e.g. for Cartesian, [(0, 0, 0), (1, 0, 0) ,…].</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray(L, M), or (ndarray(L, M), list)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.n_shells">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_shells</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.n_shells" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of shells in radial points.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.points" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinates of the grid points (centered).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray(N, 3)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.radial_component_splines">
<span class="sig-name descname"><span class="pre">radial_component_splines</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.radial_component_splines" title="Permalink to this definition">¶</a></dt>
<dd><p>Return spline to interpolate radial components wrt to expansion in real spherical harmonics.</p>
<p>For each pt <span class="math notranslate nohighlight">\(r_i\)</span> of the atomic grid with associated angular degree <span class="math notranslate nohighlight">\(l_i\)</span>,
the function <span class="math notranslate nohighlight">\(f(r_i, \theta, \phi)\)</span> is projected onto the spherical
harmonic expansion:</p>
<div class="math notranslate nohighlight">
\[f(r_i, \theta, \phi) \approx \sum_{l=0}^{l_i} \sum_{m=-l}^l \rho^{lm}(r_i)
Y^m_l(\theta, \phi)\]</div>
<p>where <span class="math notranslate nohighlight">\(Y^m_l\)</span> is the real Spherical harmonic of degree <span class="math notranslate nohighlight">\(l\)</span> and order <span class="math notranslate nohighlight">\(m\)</span>.
The radial components <span class="math notranslate nohighlight">\(\rho^{lm}(r_i)\)</span> are calculated via integration on
the :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>i`th Lebedev/angular grid of the atomic grid:</p>
<div class="math notranslate nohighlight">
\[\rho^{lm}(r_i) = \int \int f(r_i, \theta, \phi) Y^m_l(\theta, \phi) \sin(\theta)
 d\theta d\phi,\]</div>
<p>and then interpolated using a cubic spline over all radial points of the atomic grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func_vals</strong> (<em>ndarray</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The function values evaluated on all <span class="math notranslate nohighlight">\(N\)</span> points on the atomic grid.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of size <span class="math notranslate nohighlight">\((l_{max}/2 + 1)^2\)</span> of  CubicSpline object for interpolating the
coefficients <span class="math notranslate nohighlight">\(\rho^{lm}(r)\)</span>. The input of spline is array
of <span class="math notranslate nohighlight">\(N\)</span> points on <span class="math notranslate nohighlight">\([0, \infty)\)</span> and the output is <span class="math notranslate nohighlight">\(\{\rho^{lm}(r_i)\}\)</span>.
The list starts with degrees <span class="math notranslate nohighlight">\(l=0,\cdots l_{max}\)</span>, and the for each degree,
the zeroth order spline is first, followed by positive orders then negative.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list[scipy.PPoly]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.rgrid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rgrid</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.rgrid" title="Permalink to this definition">¶</a></dt>
<dd><p>The radial grid representing the radius of spherical grids.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="grid.basegrid.html#grid.basegrid.OneDGrid" title="grid.basegrid.OneDGrid">OneDGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.rotate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotate</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer representing the seed for rotating the angular grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save atomic grid attributes as a npz file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> (<em>str</em>) – The path/name of the .npz file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.size" title="Permalink to this definition">¶</a></dt>
<dd><p>the total number of points on the grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.spherical_average">
<span class="sig-name descname"><span class="pre">spherical_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func_vals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#grid.atomgrid.AtomGrid.spherical_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Return spline of the spherical average of a function.</p>
<p>This function takes a function <span class="math notranslate nohighlight">\(f\)</span> evaluated on the atomic grid points and returns
the spherical average of it defined as:</p>
<div class="math notranslate nohighlight">
\[f_{avg}(r) := \frac{\int \int f(r, \theta, \phi) \sin(\theta) d\theta d\phi}{4 \pi}.\]</div>
<p>The definition is chosen such that <span class="math notranslate nohighlight">\(\int f_{avg}(r) 4\pi r^2 dr\)</span>
matches the full integral <span class="math notranslate nohighlight">\(\int \int \int f(x,y,z)dxdydz\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func_vals</strong> (<em>ndarray</em><em>(</em><em>N</em><em>,</em><em>)</em>) – The function values evaluated on all <span class="math notranslate nohighlight">\(N\)</span> points on the atomic grid.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Cubic spline with input r in the positive real axis and output <span class="math notranslate nohighlight">\(f_{avg}(r)\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>CubicSpline</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Define a Gaussian function that takes Cartesian coordinates as input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">cart_pts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cart_pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
<span class="go"># Construct atomic grid with degree 10 on a radial grid on [0, \infty)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">radial_grid</span> <span class="o">=</span> <span class="n">GaussLaguerre</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atgrid</span> <span class="o">=</span> <span class="n">AtomGrid</span><span class="p">(</span><span class="n">radial_grid</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span>
<span class="go"># Evaluate func on atmic grid points (which are stored in Cartesian coordinates)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_vals</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">atgrid</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
<span class="go"># Compute spherical average spline &amp; evaluate it on a set of (radial) points in [0, \infty)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spherical_avg</span> <span class="o">=</span> <span class="n">atgrid</span><span class="o">.</span><span class="n">spherical_average</span><span class="p">(</span><span class="n">func_vals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evals</span> <span class="o">=</span> <span class="n">spherical_avg</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="go"># the largest error happens at origin because the spline is being extrapolated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">evals</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">points</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1.0e-3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.use_spherical">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_spherical</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.use_spherical" title="Permalink to this definition">¶</a></dt>
<dd><p>True then symmetric spherical t-design is used rather than Lebedev-Laikov grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="grid.atomgrid.AtomGrid.weights">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weights</span></span><a class="headerlink" href="#grid.atomgrid.AtomGrid.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>the weights of each grid point.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>np.ndarray(N,)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="grid.basegrid.html" class="btn btn-neutral float-right" title="grid.basegrid module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="grid.angular.html" class="btn btn-neutral float-left" title="grid.angular module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2021, QC-Devs

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>